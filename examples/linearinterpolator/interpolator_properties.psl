-- If we want to be able to define processes in this file, we need to associate
-- the vunit to a specific entity/architecture pair
vunit interpolator_properties (interpolator(interpolator_arch)) {

    inherit interpolator_prop;
    -- Default clock for PSL assertions
    default clock is rising_edge(clk);

    -- Defining sequences allows for:
    --   1. Simplifying our properties
    --   2. Reusing code (write less and be less error-prone when the same
    --      sequence appears in multiple properties)
    -- An interesting sequence to see here is that, beginning from the cycle
    -- after activation, we will have a valid output each cycle for 12 cycles
    sequence twelve_estim_valid is {estim_valid[*12]};

    -- Assume a reset in the first clock cycle
    -- Since we don't have an 'always', this assumption only applies to the
    -- first clock cycle
    assume_initial_reset: assume rst = '1';

    -- Assume the interpolator will not be activated when it is in reset
    assume_not_activated_when_in_reset:
        assume always (rst) -> (not valid);
        --assume always (rst = '1') -> (valid = '0');

    -- Assume inferior and superior do not change during the 12 cycles output
    assume always ({valid} |=> {stable(inferior)[*12]}) abort rst;
    assume always ({valid} |=> {stable(superior)[*12]}) abort rst;

    -- Assume the interpolator will not be activated on the 12 cycles after
    -- being activated (the interpolator needs 12 cycles to output the 12
    -- interpolated data)
    assume_not_activated_when_interpolating:
        assume always {valid} |=> {(not valid)[*12]};

    -- After a valid input, we have one valid output, unless someone asserts
    -- the reset input
    -- (this assertion has been commented out because it is superseded by the
    -- next one, which includes the 12 cycles after assertion of valid)
    --valid_output_after_valid_input:
    --    assert always (({valid} |-> next(estim_valid)) abort rst);

    -- After a valid input, we have 12 valid outputs, unless someone asserts
    -- the reset input
    valid_outputs_after_valid_input:
        assert always (({valid} |=> twelve_estim_valid) abort rst);

    -- Cover at least one interpolation
    cover_twelve_estim_valid:
        cover twelve_estim_valid;

    -- This assertion will fire
    --assert_will_fire:
    --    assert always (({not valid} |=> twelve_estim_valid) abort rst);

    -- Input transaction assignation
    signal input_tran : interpolator_input_tran;
    input_tran.infr <= inferior;
    input_tran.supr <= superior;

    interpolator_works_correctly:
        assert interpolator_prop(input_tran, interpolator_predict(input_tran), rst);

    -- Let's cover some input combinations
    sequence input (
        hdltype signed(9 downto 0) inf_re;
        hdltype signed(9 downto 0) inf_im;
        hdltype signed(9 downto 0) sup_re;
        hdltype signed(9 downto 0) sup_im
        ) is {
        input_tran.infr.re = inf_re and
        input_tran.infr.im = inf_im and
        input_tran.supr.re = sup_re and
        input_tran.supr.im = sup_im
    };

    cover {input("1111111111", "1111111111", "0000000000", "0000000000"); twelve_estim_valid}; 
    cover {input("0000000000", "0000000000", "1111111111", "1111111111"); twelve_estim_valid}; 
}
