vunit div32 (div32(rtl)) {

    use ieee.std_logic_1164.all;
    use ieee.numeric_std.all;
    use gaisler.div32_common.all;

    -- Default clock for PSL assertions
    default clock is rising_edge(clk);

    -- Force a reset in the first clock cycle
    assume_initial_reset: assume rst = '0';

    -- Assume that the division starts only in idle state
    assume_start_in_idle:
        assume always ( divi.start -> r.state = "000" );

    -- Assume data is unsigned. For now, we are just testing unsigned division
    assume_data_unsigned: assume always ( divi.signed = '0' );
  
    -- Assume data is unsigned. For now, we are just testing unsigned division
    assume_y_unsigned: assume always (divi.y(32) = '0');
    assume_op1_unsigned: assume always (divi.op1(32) = '0');
    assume_op2_unsigned: assume always (divi.op2(32) = '0'); 

    -- Only considering some values for the division
    assume always ( divi.y(29 downto 20) = "0000000000" );
    assume always ( divi.op1(29 downto 20) = "0000000000" );
    assume always ( divi.op2(29 downto 20) = "0000000000" );
    assume always ( divi.y(18 downto 8) = "00000000000" );
    assume always ( divi.op1(18 downto 8) = "00000000000" );
    assume always ( divi.op2(18 downto 8) = "00000000000" );
    assume always ( divi.y(6 downto 2) = "00000" );
    assume always ( divi.op1(6 downto 2) = "00000" );
    assume always ( divi.op2(6 downto 2) = "00000" );

    -- Assert that the division is not ready when is flushed
    assert_flush: assert always ( {divi.flush: not divo.ready} |=> {not divo.ready} ) abort (rst = '0');

    -- Assert that the division is done in 36 cycles,
    -- it is aborted if the holdn signal is active 
    -- or if the division is flushed or if the reset is active
    assert_divider_36_cycles: 
        assert always ( ( ( {divi.start; true[*34]} |=> {divo.ready} ) abort (holdn = '0') ) abort divi.flush ) abort (rst = '0');

    sequence stable_inputs is {                                    
        (stable(divi.y) and stable(divi.op1) and stable(divi.op2))[*34]
    }; 

    sequence result_ready is {                                    
        divo.ready: divo.icc="0000"; divo.icc="0000"
    }; 
    -- Assert that the division is correct.
    -- The inputs divi.y, divi.op1 and divi.op2 must be stable
    -- during the division. divo.icc is "0000" to avoid overflows,
    -- zeros or signed values.
    assert_check_divider: 
        assert always ( ( {divi.start; stable_inputs; result_ready} |-> 
        { divo.result = verify_division(prev(divi.y,2), prev(divi.op1,2), prev(divi.op2,2)) } ) 
        abort (holdn = '0') ) abort (rst = '0');

    -- Cover one division
    cover_one_division: cover{[*]; divo.ready: rst};
    -- Cover two divisions
    cover_two_divisions: cover{[*]; divo.ready: rst: holdn; [*]; divo.ready: rst: holdn};

    sequence input (
        hdltype std_logic_vector(32 downto 0) y;
        hdltype std_logic_vector(32 downto 0) op1;
        hdltype std_logic_vector(32 downto 0) op2
        ) is {
        divi.start = '1' and          
        divi.y = y and   
        divi.op1 = op1 and
        divi.op2 = op2 and
        rst = '1'                                 
    }; 

    -- Cover a few specific inputs
    --cover {input("010101010101010101010101010101010", "010101010101010101010101010101010", "010101010101010101010101010101010"); rst[*35]};
    --cover {input("100111111111001000111001011011010", "000111111110001000011001110001010", "110011110101111001000111100001011"); rst[*35]};
    --cover {input("000000001111111111111111111111111", "000111111110001000011001110001010", "000000000000000000000000000000000"); rst[*35]};
    --cover {input("000000001111111111111111111111111", "000111111110001000011001110001010", "000000000000000000000000000001110"); rst[*35]};

}
