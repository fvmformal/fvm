-- Copyright 2024-2026 Universidad de Sevilla
-- SPDX-License-Identifier: Apache-2.0

vunit sdram_properties (sdram(arch)) {

    -- In this example, we inherit a lot of files instead of writing
    -- everything in this file. This is done to improve modularity and
    -- readability.

    -- Inherit reusable SDRAM sequences
    inherit sdram_sequences;
    -- Inherit reusable handshake properties
    inherit handshake_sequences;
    -- Inherit read sequences generated from JSON files
    inherit read_seq;
    -- Inherit write sequences generated from JSON files
    inherit write_seq;

    -- Default clock for PSL assertions
    default clock is rising_edge(clk);

    -- Force a reset in the first clock cycle
    assume_initial_reset: assume reset = '1';

    -- Handshake properties
    assume active_until_handshake(req, ack);
    assume we_stable_until_handshake(req, ack, we);
    assume addr_stable_until_handshake(req, ack, addr);
    assume data_stable_until_handshake(req, ack, data);

    -- Symbolic constants for drom2psl-generated sequences
    signal addr_sig : unsigned(22 downto 0);
    signal data_sig : std_logic_vector(31 downto 0);
    assume always ({true} |=> {addr_sig = prev(addr_sig)}) abort reset;
    assume always ({true} |=> {data_sig = prev(data_sig)}) abort reset;

    -- Write property generated by drom2psl
    write_is_correct:
        assert write_seq(addr_sig, data_sig, reset);
    -- Read property generated by drom2psl
    read_is_correct:
        assert read_seq(addr_sig, reset);

    -- The properties generated with drom2psl cover the main use cases
    -- (although perhaps another one describing REFRESH would be necessary).
    -- The rest of the file uses a different approach, writing shorter
    -- properties, although these could also be written with drom2psl.

    -- Our example uses shorter wait times compared to a commercial
    -- SDRAM to make verification easier.
    -- Note that the wait times are calculated based on the data from
    -- our example and are not parameterized.

    -- Startup delay sequences
    startup_delay_1:
        assert always ( {prev(reset)} |-> {command_nop} ) abort reset;
    startup_delay_2:
        assert always ( {prev(reset); true} |-> {command_deselect} ) abort reset; 
    startup_delay_3:
        assert always ( {prev(reset); true; true} |-> {command_precharge} ) abort reset; -- [*INIT_WAIT]
    startup_delay_4:
        assert always ( {prev(reset); true; true; true} |-> {command_auto_refresh} ) abort reset; -- [*INIT_WAIT+PRECHARGE_WAIT]
    startup_delay_5:
        assert always ( {prev(reset); true; true; true; true} |-> {command_auto_refresh} ) abort reset; -- [*INIT_WAIT+PRECHARGE_WAIT+REFRESH_WAIT]
    startup_delay_6:
        assert always ( {prev(reset); true; true; true; true; true} |-> {command_load_mode} ) abort reset; -- [*INIT_WAIT+PRECHARGE_WAIT+REFRESH_WAIT+REFRESH_WAIT+LOAD_MODE_WAIT]
    startup_delay_7:
        assert always ( {prev(reset); true; true; true; true; true; true} |-> {command_nop} ) abort reset; -- [*INIT_WAIT+PRECHARGE_WAIT+REFRESH_WAIT+REFRESH_WAIT+LOAD_MODE_WAIT]
    startup_delay_and_auto_refresh:
        assert always ( {prev(reset); true; true; true; true; true; (req = '0')[*62]} |=> {command_auto_refresh} ) abort reset; -- [*REFRESH_INTERVAL-previous waits]
    startup_delay_and_active:
        assert always ( {prev(reset); true; true; true; true; true; (req = '0')[*0 to 60]; req = '1'} |=> {command_active} ) abort reset;

    -- If write enable is active in state ACTIVE,
    -- the next state will be WRITE
    assert_we_next_write:
        assert always ( { we; command_active } |=> { command_write } ) abort reset;

    -- If write enable is not active in state ACTIVE,
    -- the next state will be READ
    assert_not_we_next_read:
        assert always ( { not we; command_active } 
        |=> { command_read } ) abort reset;

    -- If there isn't a reset in 68 cycles, it will autorefresh.
    -- The autorefresh happens when the current command ends,
    -- so when autorefresh is needed the should_refresh signal
    -- is asserted, and the autorefresh command when the current command ends.
    -- Why true[*5]? Because at cycle 4 and 5 after reset,
    -- there are two autorefresh commands during initialization.
    auto_refresh_after_68_cycles:
        assert always ( {true[*5]; command_auto_refresh} |=> {no_command_auto_refresh[*68]}) abort reset;
    auto_refresh_triggers_command:
        assert always ( {true[*5]; command_auto_refresh;
                        true[*68]} |-> {should_refresh}) abort reset;

    -- We have used command_active as a precondition for read and write commands.
    -- Now we check that we get to command_active when needed.
    active_after_req_1:
        assert always ( {true[*5]; command_auto_refresh: req = '1'} |=> {command_active} ) abort reset;
    active_after_req_2:
        assert always ( {true[*5]; command_auto_refresh: req = '0';
                        (req = '0')[*0 to 66];
                        req = '1'} |=> {command_active} ) abort reset;
    refresh_after_refresh:
        assert always ( {true[*5]; command_auto_refresh: req = '0';
                        (req = '0')[*67];
                        true} |=> {command_auto_refresh} ) abort reset;

    active_after_req_3:
        assert always ( {command_write; true;
                        (req = '0' and should_refresh = '0')[*];
                        req = '1' and should_refresh = '0'}
                        |=> {command_active} ) abort reset;
    active_after_req_4:
        assert always ( {command_read; true[*2];
                        (req = '0' and should_refresh = '0')[*];
                        req = '1' and should_refresh = '0'}
                        |=> {command_active} ) abort reset;

    -- This value is always 0
    assert_sdram_dqmh_0: assert always (sdram_dqmh = '0');
    -- This value is always 0
    assert_sdram_dqml_0: assert always (sdram_dqml = '0');
    -- This value is always 0 except from two cycles after the reset
    assert_sdram_cs_n_after_2_reset: assert always (sdram_cs_n -> prev(reset,2));
    -- This value is always 1 except from reset or a cycle after the reset
    assert_sdram_cke_after_reset:
        assert always ( {true; sdram_cke = '0'} |-> {reset or prev(reset)} );

    -- Assert correct read data is received after a read command
    valid_after_read:
        assert always ( {command_active; command_read; true[*4]} |-> {valid} ) abort reset;
    q_lsb_correct:
        assert always ( {command_active; command_read; true[*4]} |-> {q (15 downto 0) = prev(sdram_dq)} ) abort reset;
    q_msb_correct:
        assert always ( {command_active; command_read; true[*4]} |-> {q (31 downto 16) = prev(sdram_dq,2)} ) abort reset;

    -- Assert the sdram controller receives the correct address
    assert_sdram_ba_correct:
        assert always ( { command_write } 
        |-> { prev(sdram_ba) = prev(addr(22 downto 21),2) } ) abort reset;

    -- Assert the sdram controller receives the correct address
    assert_sdram_a_correct:
        assert always ( { command_write } 
        |-> { prev(sdram_a) = prev(addr(20 downto 8),2) } ) abort reset;

    -- Assert the sdram controller receives the correct address
    assert_sdram_a_correct_2:
        assert always ( { command_write } 
        |-> { sdram_a = "0010" & prev(addr(7 downto 0),2) & '0' } ) abort reset;

    -- Assert the sdram controller receives the correct data
    assert_sdram_dq_correct:
        assert always ( { command_write } 
        |-> { sdram_dq = prev(data(31 downto 16), 2) } ) abort reset;

    -- Assert the sdram controller receives the correct data
    assert_sdram_dq_correct_2:
        assert always ( { command_write } 
        |=> { sdram_dq = prev(data(15 downto 0), 3) } ) abort reset;

    -- Define this sequence as a start to some covers
    sequence no_rst is {                                                                        
       reset = '1'; (reset = '0')[*]
   };
    -- Cover a few states and transitions. This is not necessary,
    -- but it can be used to check states or transitions that
    -- we consider important.
    cover_transition_to_refresh_1: cover {no_rst; reset = '0' and state = IDLE;    reset = '0' and state = REFRESH};
    cover_transition_to_refresh_2: cover {no_rst; reset = '0' and state = READ;    reset = '0' and state = REFRESH};
    cover_transition_to_refresh_3: cover {no_rst; reset = '0' and state = WRITE;   reset = '0' and state = REFRESH};
    cover_transition_to_idle_1:    cover {no_rst; reset = '0' and state = REFRESH; reset = '0' and state = IDLE};
    cover_transition_to_idle_2:    cover {no_rst; reset = '0' and state = READ;    reset = '0' and state = IDLE};
    cover_transition_to_idle_3:    cover {no_rst; reset = '0' and state = WRITE;   reset = '0' and state = IDLE};
    cover_transition_to_active_1:  cover {no_rst; reset = '0' and state = REFRESH; reset = '0' and state = ACTIVE};
    cover_transition_to_active_2:  cover {no_rst; reset = '0' and state = READ;    reset = '0' and state = ACTIVE};
    cover_transition_to_active_3:  cover {no_rst; reset = '0' and state = WRITE;   reset = '0' and state = ACTIVE};

    -- Let's cover the read and write sequences with
    -- minimum and maximum values for address and data
    -- to cover all toggles.
    constant max_addr : unsigned(22 downto 0) := to_unsigned(2**23 - 1, 23);
    constant min_addr : unsigned(22 downto 0) := to_unsigned(0, 23);
    constant max_data : std_logic_vector(31 downto 0) := x"FFFFFFFF";
    constant min_data : std_logic_vector(31 downto 0) := x"00000000";
    cover {read_seq_Precond(min_addr): read_seq_Cond(min_addr):
            [*];
            read_seq_Precond(max_addr): read_seq_Cond(max_addr)};
    cover_read_values: cover {valid = '1' and q = x"0000" & X"FFFF" and reset = '0';
                                (reset = '0')[*];
                                valid = '1' and q = x"FFFF" & X"0000" and reset = '0';
                                (reset = '0')[*];
                                valid = '1' and q = x"0000" & X"FFFF" and reset = '0';
                                (reset = '0')[*];
                                valid = '1' and q = x"FFFF" & X"0000" and reset = '0'};
    cover_read_addr: cover {command_read: sdram_a = "0010" & "00000000" & '0' and
                            sdram_ba = "00" and reset = '0';
                            (reset = '0')[*];
                            command_read: sdram_a = "0010" & "11111111" & '0' and
                            sdram_ba = "11" and reset = '0';
                            (reset = '0')[*];
                            command_read: sdram_a = "0010" & "00000000" & '0' and
                            sdram_ba = "00" and reset = '0'};

    -- These covers are not ideal, but this is the only way to cover
    -- the full range of toggles of the symbolic constants in PSL.
    -- Because, all covers will likely use the same symbolic constants,
    -- and therefore, they will not cover all the toggles. Another option
    -- would be to ignore/exclude symbolic constants from simulation coverage.
    cover {addr_sig = min_addr; (reset = '0')[*]; addr_sig = max_addr; (reset = '0')[*]; addr_sig = min_addr};
    cover {data_sig = min_data; (reset = '0')[*]; data_sig = max_data; (reset = '0')[*]; data_sig = min_data};

}