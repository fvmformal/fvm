-- Copyright 2024-2026 Universidad de Sevilla
-- SPDX-License-Identifier: Apache-2.0

vunit uart_tx_properties (uart_tx(Behavioral)) {

  inherit uart_prop;
  -- Default clock
  default clock is rising_edge (clk);

  -- Assume a reset on the first clock cycle
  assume_initial_reset: assume rst = '1';

  -- Assert the UART never reads from an empty FIFO
  never_read_from_empty_fifo:
    assert never (rd_en and empty);

  -- Assume external FIFOs are always empty when in rst (so the uart_tx logic
  -- doesn't assert rd_en while in rst). This is the kind of assumption we MUST
  -- verify, either formally (preferred) or in simulation, when integrating
  -- with the FIFO module
  assume_fifo_empty_in_reset:
    assume always rst -> empty;

  -- Symbolic constant for the data being transmitted
  signal data_uart : std_logic_vector(7 downto 0);
  assume always ( {true} |=> {data_uart = prev(data_uart)} ) abort rst;

  -- Functions can be defined in PSL or in a VHDL package.
  -- The latter is preferred, but this is just an example
  function calc_parity(
      data_vec    : std_logic_vector
  ) return std_logic is
      variable parity_bit : std_logic := '0';
  begin
      for i in data_vec'range loop
          parity_bit := parity_bit xor data_vec(i);
      end loop;

      return parity_bit;
  end function;

  -- Assert the drom2psl-generated property
  assert_tx:
    assert uart_prop(data_uart, calc_parity(data_uart), rst);

  -- Cover the drom2psl-generated property (since cover needs a sequence,
  -- we need to use the sequences that uses the property in the same order)
  cover_tx:
    cover {uart_prop_Precond(data_uart);
          uart_prop_Cond_non_overlap(data_uart, calc_parity(data_uart))};

  -- We have used rd_en (output) in the precondition of the property.
  -- So, we have to verify that rd_en only happens when we want it to
  -- happen, to avoid verification gaps. It doesn't necessarily have
  -- to be with formal verification, but it's preferable.

  -- rd_en can happen in two scenarios:
  -- 1) right after reset, when the FIFO is not empty
  -- 2) after a full transmission has completed, when the FIFO is not empty
  sequence rd_en_seq_1 is {
    rst = '1';
    (empty = '1')[*];
    empty = '0'
  };

  sequence rd_en_seq_2 is {
    rd_en = '1';
    (rst = '0')[*(1+BIT_DURATION*11)]; -- time for one full transmission
    (empty = '1')[*];
    empty = '0'
  };

  -- This couple of assertions make sure that rd_en happens
  -- if the preconditions are met
  rd_en_precond_1: assert always ({ rd_en_seq_1 } |-> {rd_en = '1'});
  rd_en_precond_2: assert always ({ rd_en_seq_2 } |-> {rd_en = '1'});

  -- But we would also want to make sure that rd_en only happens
  -- when one of the preconditions are met, to avoid spurious rd_en pulses
  -- that could hide bugs in the design. So, we can use the operator ended
  -- and change the condition and precondition, but some tools might not support
  -- this operator.
  rd_en_only_happens_after_precond:
    assert always ( {rd_en = '1'} |-> { ended(rd_en_seq_1) or ended(rd_en_seq_2) });


  -- Let's define a sequence for a full transmission.
  -- We can then reuse this sequence in multiple cover properties,
  -- so we define the sequence to avoid defining the parameters multiple times.
  sequence transmission is {
    uart_prop_Cond_non_overlap(data_uart, calc_parity(data_uart))
  };

  -- Cover one correct transmission
  cover_one_transmission:
    cover transmission;
    --cover {rd_en; not rd_en; transmission};

  -- Cover two transmissions
  -- Note that this design needs at least two clock cycles between
  -- transmissions (for the states 'reposo' (idle) and 'sampledata'), so the
  -- sequence {transmission; transmission} is uncoverable, while
  -- {transmission; true[2]; transmission} can be covered

  -- Uncoverable
  --cover_two_transmisions_no_cycles_between_them:
  --  cover {transmission; transmission};

  -- Uncoverable
  --cover_two_transmisions_one_cycle_between_them:
  --  cover {transmission; true; transmission};

  cover_two_transmisions_two_cycles_between_them:
    cover {transmission; true[*2]; transmission};

  cover_two_transmisions_any_cycles_between_them:
    cover {transmission; true[*]; transmission};

  -- We can define sequences reusing other sequences, which is helpful to
  -- construct more complex sequences
  sequence transmission_and_rest is {
    transmission; true[*2]; true[*]
  };

  -- Change the number below to the number of transmissions you want to see in
  -- your cover trace
  cover_more_than_two_transmissions:
    cover {transmission_and_rest[*3]};

  cover_end_of_transmission: 
    cover {state = b_stop; state = reposo};

  sequence transmission_with_param (
    hdltype std_logic_vector(7 downto 0) data_val
  ) is {
    uart_prop_Cond_non_overlap(data_val, calc_parity(data_val))
  };

  -- Cover transmission of specific data values. This is useful to
  -- because formal verification might cover the sequences using
  -- always the same value and maybe is all zeros because it's easier
  -- for the solver. So, we can force specific values to be covered
  -- using this kind of cover.
  cover_specific_data_values:
    cover {transmission_with_param(x"00");
           transmission_with_param(x"55");
           transmission_with_param(x"A3");
           transmission_with_param(x"7E");
           transmission_with_param(x"FF");
           transmission_with_param(x"00")};

  -- This cover is not ideal, but this is the only way to cover
  -- the full range of toggles of the symbolic constants in PSL.
  -- Because, all covers will likely use the same value of the symbolic constant,
  -- and therefore, they will not cover all the toggles. Another option
  -- would be to ignore/exclude symbolic constants from simulation coverage.
  cover {data_uart = x"00"; (rst = '0')[*]; data_uart = x"FF"; (rst = '0')[*]; data_uart = x"00"};
}
