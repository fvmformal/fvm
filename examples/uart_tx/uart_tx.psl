vunit uart_tx_properties (uart_tx(Behavioral)) {

  inherit uart_prop;
  -- Default clock
  default clock is rising_edge (clk);

  -- Assume a reset on the first clock cycle
  assume_initial_reset: assume rst = '1';

  -- Assert the UART never reads from an empty FIFO
  never_read_from_empty_fifo:
    assert never (rd_en and empty);

  -- Assume external FIFOs are always empty when in rst (so the uart_tx logic
  -- doesn't assert rd_en while in rst). This is the kind of assumption we MUST
  -- verify, either formally (preferred) or in simulation, when integrating
  -- with the FIFO module
  assume_fifo_empty_in_reset:
    assume always rst -> empty;

  -- Symbolic constant for the data being transmitted
  signal data_uart : std_logic_vector(7 downto 0);
  assume always ( {true} |=> {data_uart = prev(data_uart)} ) abort rst;

  -- Functions can be defined in PSL or in a VHDL package.
  -- The latter is preferred, but this is just an example
  function calc_parity(
      data_vec    : std_logic_vector
  ) return std_logic is
      variable parity_bit : std_logic := '0';
  begin
      for i in data_vec'range loop
          parity_bit := parity_bit xor data_vec(i);
      end loop;

      return parity_bit;
  end function;

  assert_tx:
    assert uart_prop(data_uart, calc_parity(data_uart), rst);

  cover_tx:
    cover {uart_prop_Precond(data_uart);
          uart_prop_Cond_non_overlap(data_uart, calc_parity(data_uart))};

  sequence rd_en_seq_1 is {
    rst = '1';
    (empty = '1')[*];
    empty = '0'
  };

  sequence rd_en_seq_2 is {
    rd_en = '1';
    (rst = '0')[*(1+BIT_DURATION*11)]; -- time for one full transmission
    (empty = '1')[*];
    empty = '0'
  };

  rd_en_precond_1: assert always ({ rd_en_seq_1 } |-> {rd_en = '1'});
  rd_en_precond_2: assert always ({ rd_en_seq_2 } |-> {rd_en = '1'});

  rd_en_only_happens_after_precond:
    assert always ( {rd_en = '1'} |-> { ended(rd_en_seq_1) or ended(rd_en_seq_2) });


  -- Let's define a sequence for a full transmission.
  -- We can then reuse this sequence in multiple cover properties,
  -- so we define the sequence to avoid defining the parameters multiple times.
  sequence transmission is {
    uart_prop_Cond_non_overlap(data_uart, calc_parity(data_uart))
  };

  -- Cover one correct transmission
  cover_one_transmission:
    cover transmission;
    --cover {rd_en; not rd_en; transmission};

  -- Cover two transmissions
  -- Note that this design needs at least two clock cycles between
  -- transmissions (for the states 'reposo' (idle) and 'sampledata'), so the
  -- sequence {transmission; transmission} is uncoverable, while
  -- {transmission; true[2]; transmission} can be covered

  -- Uncoverable
  --cover_two_transmisions_no_cycles_between_them:
  --  cover {transmission; transmission};

  -- Uncoverable
  --cover_two_transmisions_one_cycle_between_them:
  --  cover {transmission; true; transmission};

  cover_two_transmisions_two_cycles_between_them:
    cover {transmission; true[*2]; transmission};

  cover_two_transmisions_any_cycles_between_them:
    cover {transmission; true[*]; transmission};

  -- We can define sequences reusing other sequences, which is helpful to
  -- construct more complex sequences
  sequence transmission_and_rest is {
    transmission; true[*2]; true[*]
  };

  -- Change the number below to the number of transmissions you want to see in
  -- your cover trace
  cover_more_than_two_transmissions:
    cover {transmission_and_rest[*3]};

  cover_end_of_transmission: 
    cover {state = b_stop; state = reposo};

}
