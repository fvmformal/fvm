-- Copyright 2024-2026 Universidad de Sevilla
-- SPDX-License-Identifier: Apache-2.0

vunit fifo_sync (olo_base_fifo_sync(rtl)) {

  --inherit fifo_sync_common;

  --use work.fifo_sync_common.all;
  -- Default clock for PSL assertions
  default clock is rising_edge(Clk);

  -- Force a reset in the first clock cycle
  assume_initial_reset: assume Rst = '1';

  -- This way is easier to visualize data (NOT A NECESSARY ASSUME)
  --assume always In_Valid -> not(In_Data = "000");

  -- This way is easier to visualize data, otherwise it keeps
  -- the same value of In_Data (NOT A NECESSARY ASSUME)
  --assume always ( In_Valid -> (In_Data /= prev(In_Data)) ) abort Rst;

  -- Assert the FIFO is never full and the input is ready
  assert_never_full_and_in_ready:
      assert (never (Full and In_Ready) ) abort Rst;

  -- Assert the FIFO is never empty and the output is valid
  assert_never_empty_and_out_valid:
      assert (never (Empty = '1' and Out_Valid = '1') ) abort Rst;

  -- Assert the FIFO is never full and empty at the same time
  assert_never_empty_and_full:
      assert (never (Empty = '1' and Full = '1') ) abort Rst;

  -- Assert the FIFO level calculated on the write side is always
  -- less than the depth of the FIFO
  assert_in_level_within_bounds:
      assert always (unsigned(In_Level) <= Depth_g) abort Rst;

  -- Assert the FIFO level calculated on the read side is always
  -- less than the depth of the FIFO
  assert_out_level_within_bounds:
      assert always (unsigned(Out_Level) <= Depth_g) abort Rst;

  -- Assert when empty the read level is 0
  assert_empty_out_level_0:
      assert always (Empty = '1' -> unsigned(Out_Level) = 0) abort Rst;

  -- Assert when full the write level is 8 (depth of the FIFO)
  assert_full_in_level_8:
      assert always (Full = '1' -> unsigned(In_Level) = Depth_g) abort Rst;

  -- Assert the write level is, at most, 2 plus the read level,
  -- because latency of the RAM is 1.
  assert (never ( (unsigned(In_Level) - unsigned(Out_Level) ) > 2) ) abort Rst;

  -- Assert the write level is bigger or equals to the read level
  assert always ( unsigned(In_Level) >= unsigned(Out_Level) ) abort Rst;

  -- Assert not Out_Valid after In_Level = 0 because RAM has latency 1
  assert_not_out_valid_after_in_level_0:
      assert always { unsigned(In_Level) = 0 } |=> { not Out_Valid } abort Rst;

  signal in_cnt: unsigned(log2ceil(Depth_g) - 1 downto 0);
  signal out_cnt: unsigned(log2ceil(Depth_g) - 1 downto 0);

  -- Process to count number of valid writes and reads
  process(clk)
  begin
    if rising_edge(clk) then
      if rst = '1' then
        in_cnt <= to_unsigned(0, in_cnt'length);
        out_cnt <= to_unsigned(0, out_cnt'length);
      else

        -- Accumulate valid writes
        if In_Valid = '1' and In_Ready = '1' then
          in_cnt <= in_cnt + 1;
        end if;

        -- Accumulate valid reads
        if Out_Ready = '1' and Out_Valid = '1' then
          out_cnt <= out_cnt + 1;
        end if;
      end if;
    end if;
  end process;

  signal a : std_logic_vector(Width_g-1 downto 0);
  assume always ({true} |=> {a = prev(a)}) abort Rst;

  sequence write_seq is {
      In_Ready = '1' and In_Valid = '1'
  };

  sequence in_data_pos_j (
      hdltype std_logic_vector(Width_g-1 downto 0) a;
      hdltype unsigned(log2ceil(Depth_g) - 1 downto 0) j
      ) is {                                                                        
      write_seq: 
      In_Data = a:
      in_cnt = j
   };

  sequence no_pos_j (
      hdltype unsigned(log2ceil(Depth_g) - 1 downto 0) j
      ) is {                                                                        
      (out_cnt /= j)[*]
   };

  sequence read_seq is {
      Out_Valid:
      Out_Ready
  };

  sequence out_valid_pos_j (
      hdltype unsigned(log2ceil(Depth_g) - 1 downto 0) j
      ) is {                                                                        
      read_seq: 
      out_cnt = j
   };

  -- With the number of valid writes and reads, we can
  -- check that data read is the same as data written.
  %for j in 0..7 do
    assert always ( { in_data_pos_j(a, to_unsigned(j, in_cnt'length)); no_pos_j(to_unsigned(j, out_cnt'length)); 
                      out_valid_pos_j(to_unsigned(j, out_cnt'length))} |-> {Out_Data = a} ) abort Rst;
  %end

  sequence write_seq_no_rst is {
      write_seq: 
      Rst = '0'
  };

  sequence read_seq_no_rst is {
      read_seq:
      Rst = '0'
  };

  sequence write_FIFO is {
      [*];
      write_seq_no_rst: countones(In_Data) = 0;
      write_seq_no_rst: countones(In_Data) = Width_g;
      write_seq_no_rst: countones(In_Data) = 0;
      write_seq_no_rst;
      write_seq_no_rst;
      write_seq_no_rst
  };

  sequence read_FIFO is {
      [*];
      read_seq_no_rst[*7]
  };

  -- Cover all the important events in a FIFO: write, read,
  -- full, empty...
  cover_write_and_read_FIFO: cover{rst; write_FIFO; read_FIFO; write_FIFO; [*]; Full; (not Rst)[*10]; Empty; [*]; Full};

  sequence toggle_a_1 is {
    countones(a) = Width_g and rst = '1'; 
    countones(a) = 0 and rst = '0'
  };

  sequence toggle_a_2 is {
    countones(a) = 0 and rst = '1'; 
    countones(a) = Width_g and rst = '0'
  };
  -- This cover is not ideal, but this is the only way to cover
  -- the full range of toggles of the symbolic constants in PSL.
  -- Because, all covers will likely use the same value of the symbolic constant,
  -- and therefore, they will not cover all the toggles. Another option
  -- would be to ignore/exclude symbolic constants from simulation coverage.
  cover{toggle_a_1};
  cover{toggle_a_2};
  
}
