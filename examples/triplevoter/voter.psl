-- If we want to be able to define processes in this file, we need to associate                                                                                                           
-- the vunit to a specific entity/architecture pair
vunit voter (voter(voter_arch)) {

    -- Default clock for PSL assertions
    -- Since the circuit is purely combinatorial, let's declare a clk signal
    -- here
    signal clk: std_logic;
    default clock is rising_edge(clk);

    -- This assertion is ok, but it is computing the expected output in exactly
    -- the same way than the VHDL, so it is not by itself a sensible way of
    -- verifying the module
    output_is_the_majority_of_inputs_1:
        assert always output -> ((input(0) and input(1)) or
                                 (input(0) and input(2)) or
                                 (input(1) and input(2)));

    -- Now let's compute the expected output in a different way than in the VHDL
    signal expected: std_logic;

    compute_expected_output: process(input)
    begin
        if input(0) = input(1) then
            expected <= input(0);  -- input(0) and input(1) are majority
        elsif input(0) = input(2) then
            expected <= input(0);  -- input(0) and input(2) are majority
        else
            expected <= input(1);  -- input(1) and input(2) are majority
        end if;
    end process;

    -- Assert the output is actually the majority of the inputs
    output_is_the_majority_of_inputs_2:
        assert always (output = expected);

    -- Let's cover some cases:
    cover_all_inputs_one:
        cover {input = "111"};

    cover_all_inputs_zero:
        cover {input = "111"};

    cover_inputs_zero_and_one_differ:
        cover {input(0) /= input(1)};

    cover_inputs_zero_and_two_differ:
        cover {input(0) /= input(2)};

    cover_inputs_one_and_two_differ:
        cover {input(1) /= input(2)};

}
