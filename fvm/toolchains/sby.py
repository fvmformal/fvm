# SymbiYosys toolchain definition

import os
from collections import OrderedDict

# TODO : auto-detect if we have to pass the --yosys "yosys -m ghdl" option to
# sby or not. For now we will always pass it, because compiling the ghdl
# synthesis module separately is the recommended way of using ghdlsynth with
# yosys. We could also add support for synthesis with Verific, but we don't
# have a license.

# TODO : how to explore depth in this toolchain? The most user-friendly way
# would be to automatically set it, increasing it if cover traces are not
# reached (and not uncoverable) and induction fails (but basecase doesn't). But
# that would require the run_prove function to iterate over a number of sby
# executions, so let's begin first with a simpler solution where depth is fixed

# TODO : For all this file: probably forward slashes (/) are not portable and
# we should use a library to manage path operations, such as os.path or pathlib
# (pathlib seems to be more recommended)

# TODO : Not sure we really need this dict
tools = {
        "prove" : ["sby", "sby"]
        }

default_flags = {}

def define_steps(steps):
    steps.add_step('prove', setup_prove, run_prove)

def get_vhdl_compilation_order(lib):
    # TODO : run ghdl -i with all sources, then run ghdl with --elab-order
    pass

# TODO : set depths
# TODO : set engines
# TODO : bmc is commented out below because probably we don't want it if we can
# just prove the property. prove's basecase is actually a bmc, so we will know
# if bmc passes up to prove's depth. Maybe if prove fails we can launch a bmc
# with higher depth
def setup_prove(framework, path):
    print("*** sby, setup prove ***")
    filename = "prove.sby"
    library_path = f'{framework.outdir}/libs'
    os.makedirs(library_path, exist_ok=True)
    with open(f'{path}/{filename}', "w") as f:
        print(f'# Automatically generated by the FVM framework')
        print('[tasks]', file=f)
        #print('bmc', file=f)
        print('prove', file=f)
        print('cover', file=f)
        print('', file=f)
        print('[options]', file=f)
        #print('bmc: mode bmc', file=f)
        #print('bmc: depth 300', file=f)
        print('prove: mode prove', file=f)
        print('prove: depth 20', file=f)
        print('cover: mode cover', file=f)
        print('cover: depth 300', file=f)
        print('', file=f)
        print('[engines]', file=f)
        print('smtbmc', file=f)
        print('', file=f)
        print('[script]', file=f)
        # TODO : support libraries? Not sure the ghdl synthesis plugin actually
        # supports libraries: https://ghdl.github.io/ghdl/using/Synthesis.html 
        # TODO : allow user-defined flags such as -frelaxed
        prev_libs = ""
        ordered_libraries = OrderedDict.fromkeys(framework.libraries_from_vhdl_sources)
        for lib in ordered_libraries:
            os.makedirs(f'{library_path}/{lib}', exist_ok=True)
            compilation_order = get_vhdl_compilation_order(lib)
            lib_sources = [src for src, library in zip(framework.vhdl_sources,
                                                       framework.libraries_from_vhdl_sources) if library == lib]
            abspath_lib_sources = [os.path.abspath(path) for path in lib_sources]
            libpath = library_path + "/" + lib
            #print(f'ghdl -i --std=08 --work={lib} --workdir={os.path.abspath(libpath)} {prev_libs} {" ".join(abspath_lib_sources)}', file=f)
            prev_libs += f'-P{os.path.abspath(libpath)} '
        # TODO : use correct lib if the toplevel is not from work
        abspath_psl_sources = [os.path.abspath(path) for path in framework.psl_sources]
        abspath_vhdl_sources = [os.path.abspath(path) for path in framework.vhdl_sources]
        workpath = library_path + "/work"
        #print(f'ghdl -i --std=08 --work=work --workdir={os.path.abspath(workpath)} --workdir={library_path}/work {prev_libs} {" ".join(abspath_psl_sources)}', file=f)
        # TODO : Looks like sby doesn't really like relative paths because it changes into its working directory, and then struggles to find the source files
        print(f'ghdl --std=08 --work=work --workdir={os.path.abspath(workpath)} {prev_libs} {" ".join(abspath_vhdl_sources)} -e {framework.current_toplevel}', file=f)
        print(f'prep -top {framework.current_toplevel}', file=f)
        print('', file=f)
        print('[files]', file=f)
        ordered_libraries = OrderedDict.fromkeys(framework.libraries_from_vhdl_sources)
        for lib in ordered_libraries:
            lib_sources = [src for src, library in zip(framework.vhdl_sources,
                                                       framework.libraries_from_vhdl_sources) if library == lib]
            for source in lib_sources:
                print(f'{source}', file=f)
        for source in framework.psl_sources:
            print(f'{source}', file=f)
        print('', file=f)

def run_prove(framework, path):
    print("*** sby, running prove ***")
    path = f'{framework.outdir}/{framework.current_toplevel}'
    cmd = ['sby', '--yosys', 'yosys -m ghdl', '-f', f'{path}/prove.sby', '--prefix', f'{path}']
    run_stdout, run_stderr = framework.run_cmd(cmd, framework.current_toplevel, 'prove', 'sby')
    return run_stdout, run_stderr

