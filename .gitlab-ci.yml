stages:
  - lint_and_test
  - concepts
  - examples
  - coverage
  - doc
  - deploy
#  - history

count_todos_in_code:
  stage: lint_and_test
  image: debian:12
  script:
    - apt update
    - apt install -y python3 python3-pip python3-venv
    - make todo
  coverage: /Count=([\d]+)/
  artifacts:
    paths:
      - badges/todo.svg

lint_python:
  stage: lint_and_test
  image: debian:12
  script:
    - apt update
    - apt install -y python3 python3-pip python3-venv bc
    - make lint | tee pylint.log
    - RATING=$(grep -oP 'Your code has been rated at \K[\d.]+' pylint.log)
    - PERCENTAGE=$(echo "$RATING * 10" | bc)
    - printf "lint score is %.2f %%\n" "$PERCENTAGE"
  coverage: /lint score is ([\d]+\.[\d]+)/

test_all:
  stage: lint_and_test
  image: debian:12
  script:
    - apt update
    - apt install -y python3 python3-pip python3-venv
    - make test
    - mv .coverage .coverage.pytest
  artifacts:
    when: always
    paths:
      - .coverage.pytest
      - results.xml
    reports:
      junit:
        - results.xml

#generate_matrixes:
#  stage: lint_and_test
#  image: debian:12
#  script:
#    - export CONCEPTS=$(make list-concepts | tr '\n' ',')
#    - export EXAMPLES=$(make list-concepts | tr '\n' ',')

# TODO : Add artifacts, when we have a clearer idea of what those would be
# TODO : Add results.xml, when our framework generates it
run_concepts: &run_concepts
  stage: concepts
  image: registry.woden.us.es/containers/questa:2024.3
  parallel:
    matrix:
      - DESIGN: [transactions_deprecated, parameterized_sequences, inheriting_vunits, inheriting_multiple_vunits, parameterized_properties, multiple_designs, symbolic_constants, user_defined_hdltypes, user_defined_hdltypes_in_package, user_defined_hdltypes_in_external_package, assert_to_assume, defining_clocks_and_resets, hooks, design_configurations, assertion_decomposition, reachability_example]
  script:
    - unset LM_LICENSE_FILE
    - export SALT_LICENSE_SERVER=2101@baldr.us.es
    - yum install -y git python39 java-1.8.0-openjdk
    # TODO : the following 6 lines don't work, we should create the file from
    # inside the python code (see issue #165)
    - echo '{"name":"GitLab CI with runner ${CI_RUNNER_ID}","type":"gitlab","reportName":"Allure Report (without history for now)",' > executor.json
    - echo "\"reportUrl\":\"${CI_PAGES_URL}/${CI_COMMIT_REF_NAME}/${CI_JOB_ID}/\"," >> executor.json
    - echo "\"buildUrl\":\"${CI_PIPELINE_URL}\"," >> executor.json
    - echo "\"buildName\":\"GitLab Job Run ${CI_JOB_ID}\",\"buildOrder\":\"${CI_JOB_ID}\"}" >> executor.json
    - mkdir -p fvm_out/fvm_results
    - mv executor.json fvm_out/fvm_results
    - make PYTHON="coverage run --data-file=.coverage.$DESIGN" $DESIGN
  after_script:
    - mv fvm_out/fvm_report fvm_out/fvm_report.$DESIGN
  artifacts:
    when: always
    paths:
      - .coverage.$DESIGN
      - fvm_out/fvm_results/*.xml
      - fvm_out/fvm_results/executor.json
      - fvm_out/fvm_report.$DESIGN
    reports:
      junit:
        - fvm_out/fvm_results/*.xml

run_examples:
  <<: *run_concepts
  stage: examples
  parallel:
    matrix:
      - DESIGN: [counter, countervunit, linearinterpolator, dualcounter, uart_tx, arbiter_prior, arbiter_rr, fifo_sync, fifo_async, axi_lite_slave]
  # TODO : remove this when issues with the designs are fixed

# Test for #126
# TODO : This test should be done a bit differently, so we don't have to update
# it manually, for example it may get the available steps from the framework
# and then run each of them alternated with a 'make clean' inside a for loop
# TODO : this could be implemented more cleanly using parallel:matrix
run_steps_independently:
  stage: examples
  image: registry.woden.us.es/containers/questa:2024.3
  script:
    - unset LM_LICENSE_FILE
    - export SALT_LICENSE_SERVER=2101@baldr.us.es
    - yum install -y python39 java-1.8.0-openjdk
    - make PYTHON="coverage run --data-file=.coverage.$DESIGN" $DESIGN
    - source .venv/bin/activate && coverage run --data-file=.coverage.$DESIGN.lint -m examples.countervunit.formal -s lint
    - make clean
    - source .venv/bin/activate && coverage run --data-file=.coverage.$DESIGN.rulecheck --m examples.countervunit.formal -s friendliness
    - make clean
    - source .venv/bin/activate && coverage run --data-file=.coverage.$DESIGN.reachability --m examples.countervunit.formal -s reachability
    - make clean
    - source .venv/bin/activate && coverage run --data-file=.coverage.$DESIGN.resets --m examples.countervunit.formal -s resets
    - make clean
#    - coverage run -m examples.countervunit.formal -s clocks
#    - make clean
    - source .venv/bin/activate && coverage run --data-file=.coverage.$DESIGN.prove --m examples.countervunit.formal -s prove
    - make clean
  artifacts:
    when: always
    paths:
      - .coverage.*

full_dashboard:
  stage: doc
  image: debian:12
  script:
    - apt update
    - apt install -y python3 python3-pip python3-venv default-jdk
    - mv results.xml fvm_out/fvm_results
    - make report
  artifacts:
    when: always
    paths:
      - fvm_out/fvm_report

apidoc:
  stage: doc
  image: debian:12
  script:
    - apt update
    - apt install -y python3 python3-pip python3-venv
    - make docs
  artifacts:
    when: always
    paths:
      - doc/sphinx/build/html
  coverage: /Total undocumented members: ([\d]+)/

# The history is much smaller than the full dashboard, so we can afford to save
# it with a long expiry date
#save_history:
#  stage: history
#  image: debian:12
#  script:
#    - mv fvm_out/fvm_report/history history
#  artifacts:
#    when: always
#    paths:
#      - history
#    expire_in: 1 month


# TODO : merge coverage files from previous stages
pycoverage:
  stage: coverage
  image: debian:12
  script:
    - apt update
    - apt install -y python3 python3-pip python3-venv
    - make pycoverage
  coverage: /TOTAL.*\s+(\d+\%)/
  artifacts:
    when: always
    paths:
      - htmlcov
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml

# Deploy to gitlab pages
# This is done only on the main branch: if not, pages would be overwritten by
# all pipelines running in all branches, and we don't want that. We want our
# gitlab pages to point to the stable version
# TODO : maybe there is way of serving multiple versions on the gitlab pages,
# doing something similar as what we would like to do keeping the Allure
# history. See
# https://dev.to/zenika/gitlab-pages-preview-the-no-compromise-hack-to-serve-per-branch-pages-5599
# (but also look for other alternatives)
pages:
  stage: deploypages
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  script:
    - mv doc/sphinx/build/html public
    - echo Publishing gitlab pages
  artifacts:
    paths:
      - public
