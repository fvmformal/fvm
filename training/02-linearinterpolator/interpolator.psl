-- If we want to be able to define processes in this file, we need to associate
-- the vunit to a specific entity/architecture pair
vunit interpolator (interpolator(interpolator_arch)) {

    -- Default clock for PSL assertions
    default clock is rising_edge(clk);

    -- Defining sequences allows for:
    --   1. Simplifying our properties
    --   2. Reusing code (write less and be less error-prone when the same
    --      sequence appears in multiple properties)
    -- An interesting sequence to see here is that, beginning from the cycle
    -- after activation, we will have a valid output each cycle for 12 cycles
    sequence twelve_estim_valid is {estim_valid[*12]};

    -- Assume a reset in the first clock cycle
    -- Since we don't have an 'always', this assumption only applies to the
    -- first clock cycle
    assume_initial_reset: assume rst = '1';

    -- Assume the interpolator will not be activated when it is in reset
    assume_not_activated_when_in_reset:
        assume always (rst) -> (not valid);
        --assume always (rst = '1') -> (valid = '0');

    -- Assume the interpolator will not be activated on the 12 cycles after
    -- being activated (the interpolator needs 12 cycles to output the 12
    -- interpolated data)
    assume_not_activated_when_interpolating:
        assume always {valid} |=> {(not valid)[*12]};

    -- After a valid input, we have one valid output, unless someone asserts
    -- the reset input
    -- (this assertion has been commented out because it is superseded by the
    -- next one, which includes the 12 cycles after assertion of valid)
    --valid_output_after_valid_input:
    --    assert always (({valid} |-> next(estim_valid)) abort rst);

    -- After a valid input, we have 12 valid outputs, unless someone asserts
    -- the reset input
    valid_outputs_after_valid_input:
        assert always (({valid} |=> twelve_estim_valid) abort rst);

    -- Let's define the signals we need to calculate the expected output value
    signal step, n_step: integer range 0 to 12;  -- Interpolation step
    signal expected_re, expected_im: integer;  -- Expected output values

    -- Let's calculate the expected output values
    -- In order to not write the same code here than in the RTL, we'll work
    -- with integers.
    calculate_expected: process (inferior, superior, step)
    begin
        expected_re <= (to_integer(inferior.re)*(12-step) +
                        to_integer(superior.re)*step) / 16;
        expected_im <= (to_integer(inferior.im)*(12-step) +
                        to_integer(superior.im)*step) / 16;
    end process;

    -- When interpolating, we must increase the interpolation step every clock
    -- cycle
    calculate_step : process(step, valid)
    begin
        n_step <= step;
        if step = 12 then
            if valid = '1' then
                n_step <= 0;
            end if;
        else
            n_step <= step + 1;
        end if;
    end process;

    -- We need a synchronous process to store step
    sync_formal: process(clk, rst)
    begin
        if rst = '1' then
            step <= 12;
        elsif rising_edge(clk) then
            step <= n_step;
        end if;
    end process;

    -- If the output is valid, it must match the expected. Since the expected
    -- output was caculated with 32-bit integers instead of limited-size signed
    -- vectors, leave an lsb of leeway
    valid_output_values:
        assert always (estim_valid) ->
            (abs(to_integer(estim.re) - expected_re) <= 1) and
            (abs(to_integer(estim.im) - expected_im) <= 1);

    -- Cover at least one interpolation
    cover_twelve_estim_valid:
        cover twelve_estim_valid;

    -- Uncoverable clause
    --cover_uncoverable:
    --    cover {step = 14};

    -- This assertion will fire
    --assert_will_fire:
    --    assert always (({not valid} |=> twelve_estim_valid) abort rst);

}
