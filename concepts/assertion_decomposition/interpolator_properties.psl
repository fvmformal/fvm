-- Copyright 2024-2026 Universidad de Sevilla
-- SPDX-License-Identifier: Apache-2.0

-- If we want to be able to define processes in this file, we need to associate
-- the vunit to a specific entity/architecture pair
vunit interpolator_properties (interpolator(interpolator_arch)) {

    -- Default clock for PSL assertions
    default clock is rising_edge(clk);

    -- Defining sequences allows for:
    --   1. Simplifying our properties
    --   2. Reusing code (write less and be less error-prone when the same
    --      sequence appears in multiple properties)
    -- An interesting sequence to see here is that, beginning from the cycle
    -- after activation, we will have a valid output each cycle for 12 cycles
    sequence twelve_estim_valid is {estim_valid[*12]};

    -- Assume a reset in the first clock cycle
    -- Since we don't have an 'always', this assumption only applies to the
    -- first clock cycle
    assume_initial_reset: assume rst = '1';

    -- Assume the interpolator will not be activated when it is in reset
    assume_not_activated_when_in_reset:
        assume always (rst) -> (not valid);
        --assume always (rst = '1') -> (valid = '0');

    -- Assume inferior and superior do not change during the 12 cycles output
    assume always ({valid} |=> {stable(inferior)[*12]}) abort rst;
    assume always ({valid} |=> {stable(superior)[*12]}) abort rst;

    -- Assume the interpolator will not be activated on the 12 cycles after
    -- being activated (the interpolator needs 12 cycles to output the 12
    -- interpolated data)
    assume_not_activated_when_interpolating:
        assume always {valid} |=> {(not valid)[*12]};

    -- After a valid input, we have one valid output, unless someone asserts
    -- the reset input
    -- (this assertion has been commented out because it is superseded by the
    -- next one, which includes the 12 cycles after assertion of valid)
    --valid_output_after_valid_input:
    --    assert always (({valid} |-> next(estim_valid)) abort rst);

    -- After a valid input, we have 12 valid outputs, unless someone asserts
    -- the reset input
    valid_outputs_after_valid_input:
        assert always (({valid} |=> twelve_estim_valid) abort rst);

    -- Cover at least one interpolation
    cover_twelve_estim_valid:
        cover twelve_estim_valid;

    -- This assertion will fire
    --assert_will_fire:
    --    assert always (({not valid} |=> twelve_estim_valid) abort rst);

    -- Parameterizable input sequence
    sequence input_seq (
        hdltype interpolator_input_tran input_tran
        ) is {
        inferior = input_tran.infr:
        superior = input_tran.supr:
        valid    = '1'
    }; 
    
    -- Parameterizable output sequence
    sequence output_seq_0 (
    hdltype interpolator_output_tran output_tran;
    const idx
    ) is {      
        estim.re = output_tran(idx).re:
        estim.im = output_tran(idx).im:
        estim_valid = '1'                         
    };

    -- Parameterizable property that relates the input and
    -- the output sequence
    property interpolation_0(
        hdltype interpolator_input_tran input_tran;
        hdltype interpolator_output_tran output_tran;
        const idx
        ) is
        always (( {input_seq(input_tran); true[*idx]} |=> output_seq_0(output_tran, idx)) abort rst);

    -- Input transaction assignation
    signal input_tran : interpolator_input_tran;
    input_tran.infr <= inferior;
    input_tran.supr <= superior;

    -- Assert the parameterized property
    interpolator_works_correctly_0:
       assert interpolation_0(input_tran, interpolator_predict(input_tran), 0);

    -- Assert the parameterized property
    interpolator_works_correctly_1:
        assert interpolation_0(input_tran, interpolator_predict(input_tran), 1);

    -- Assert the parameterized property
    interpolator_works_correctly_2:
        assert interpolation_0(input_tran, interpolator_predict(input_tran), 2);

    -- Assert the parameterized property
    interpolator_works_correctly_3:
        assert interpolation_0(input_tran, interpolator_predict(input_tran), 3);

    -- Assert the parameterized property
    interpolator_works_correctly_4:
        assert interpolation_0(input_tran, interpolator_predict(input_tran), 4);

    -- Assert the parameterized property
    interpolator_works_correctly_5:
        assert interpolation_0(input_tran, interpolator_predict(input_tran), 5);

    -- Assert the parameterized property
    interpolator_works_correctly_6:
        assert interpolation_0(input_tran, interpolator_predict(input_tran), 6);

    -- Assert the parameterized property
    interpolator_works_correctly_7:
        assert interpolation_0(input_tran, interpolator_predict(input_tran), 7);

    -- Assert the parameterized property
    interpolator_works_correctly_8:
        assert interpolation_0(input_tran, interpolator_predict(input_tran), 8);

    -- Assert the parameterized property
    interpolator_works_correctly_9:
        assert interpolation_0(input_tran, interpolator_predict(input_tran), 9);

    -- Assert the parameterized property
    interpolator_works_correctly_10:
        assert interpolation_0(input_tran, interpolator_predict(input_tran), 10);

    -- Assert the parameterized property
    interpolator_works_correctly_11:
        assert interpolation_0(input_tran, interpolator_predict(input_tran), 11);

    sequence input (
        hdltype signed(9 downto 0) inf_re;
        hdltype signed(9 downto 0) inf_im;
        hdltype signed(9 downto 0) sup_re;
        hdltype signed(9 downto 0) sup_im
        ) is {
        input_tran.infr.re = inf_re and
        input_tran.infr.im = inf_im and
        input_tran.supr.re = sup_re and
        input_tran.supr.im = sup_im
    }; 

    cover {input("1111111111", "1111111111", "0000000000", "0000000000"); twelve_estim_valid}; 
    cover {input("0000000000", "0000000000", "1111111111", "1111111111"); twelve_estim_valid}; 
}
